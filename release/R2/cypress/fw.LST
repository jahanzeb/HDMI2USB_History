C51 COMPILER V7.07   FW                                                                    06/18/2013 00:09:31 PAGE 1   


C51 COMPILER V7.07, COMPILATION OF MODULE FW
OBJECT MODULE PLACED IN fw.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE fw.c BROWSE INCDIR(C:\Documents and Settings\prku\Desktop\UART Debug\) DEBU
                    -G OBJECTEXTEND

stmt level    source

   1          //-----------------------------------------------------------------------------
   2          //   File:      fw.c
   3          //   Contents:   Firmware frameworks task dispatcher and device request parser
   4          //            source.
   5          //
   6          // indent 3.  NO TABS!
   7          //
   8          //   Copyright (c) 1997 AnchorChips, Inc. All rights reserved
   9          //-----------------------------------------------------------------------------
  10          #include "fx2.h"
  11          #include "fx2regs.h"
  12          #include "fx2sdly.h"
  13          //-----------------------------------------------------------------------------
  14          // Random Macros
  15          //-----------------------------------------------------------------------------
  16          #define   min(a,b) (((a)<(b))?(a):(b))
  17          #define   max(a,b) (((a)>(b))?(a):(b))
  18          
  19          #define SET_LINE_CODING (0x20)
  20          #define GET_LINE_CODING (0x21)
  21          #define SET_CONTROL_STATE (0x22)
  22          
  23          //-----------------------------------------------------------------------------
  24          // Constants
  25          //-----------------------------------------------------------------------------
  26          
  27          //-----------------------------------------------------------------------------
  28          // Constants
  29          //-----------------------------------------------------------------------------
  30          //----------------------------------------------------------------------------
  31          //      UVC definations
  32          //----------------------------------------------------------------------------
  33          #define         UVC_SET_INTERFACE               0x21    // SET_Interface : UVC
  34          #define         UVC_GET_INTERFACE               0xA1    // GET_Interface : UVC
  35          
  36          #define         UVC_SET_ENDPOINT                0x22    // SET_ENDPOINT : UVC
  37          #define         UVC_GET_ENDPOINT                0xA2    // GET_ENDPOINT : UVC
  38          
  39          
  40          #define RC_UNDEFINED    0x00
  41          #define SET_CUR                 0x01
  42          #define SET_CUR_ALL     0x11
  43          #define GET_CUR                 0x81 // 1
  44          #define GET_MIN                 0x82 //
  45          #define GET_MAX                 0x83 // 2
  46          #define GET_RES                 0x84
  47          #define GET_LEN                 0x85
  48          #define GET_INFO                0x86
  49          #define GET_DEF                 0x87
  50          #define GET_CUR_ALL     0x91
  51          #define GET_MIN_ALL     0x92
  52          #define GET_MAX_ALL     0x93
  53          #define GET_RES_ALL     0x94
  54          #define GET_DEF_ALL     0x97
C51 COMPILER V7.07   FW                                                                    06/18/2013 00:09:31 PAGE 2   

  55          
  56          
  57          //-----------------------------------------------------------------------------
  58          // Global Variables
  59          //-----------------------------------------------------------------------------
  60          volatile BOOL   GotSUD;
  61          BOOL      Rwuen;
  62          BOOL      Selfpwr;
  63          volatile BOOL   Sleep;                  // Sleep mode enable flag
  64          int i;
  65          BYTE Len;
  66          BYTE xdata LineCode[7] = {0x60,0x09,0x00,0x00,0x00,0x00,0x08};
  67          // extern void Serial0Init();
  68          
  69          WORD   pDeviceDscr;   // Pointer to Device Descriptor; Descriptors may be moved
  70          WORD   pDeviceQualDscr;
  71          WORD   pHighSpeedConfigDscr;
  72          WORD   pFullSpeedConfigDscr;   
  73          WORD   pConfigDscr;
  74          WORD   pOtherConfigDscr;   
  75          WORD   pStringDscr;   
  76          
  77          BYTE valuesArray[26]=    
  78          {
  79                  0x01,0x00,                       /* bmHint : No fixed parameters */
  80              0x01,                            /* Use 1st Video format index */
  81              0x01,                            /* Use 1st Video frame index */
  82              0x2A,0x2C,0x0A,0x00,             /* Desired frame interval in 100ns */
  83                  
  84              0x01,0x00,                       /* Key frame rate in key frame/video frame units */
  85              0x01,0x00,                       /* PFrame rate in PFrame / key frame units */
  86              0x00,0x00,                       /* Compression quality control */
  87              0xf0,0x00,                       /* Window size for average bit rate */
  88                  
  89              0x02,0x00,                       /* Internal video streaming i/f latency in ms */
  90              // 0x00,0x00,0x48,0x00,                     /* Max video frame size in bytes*/
  91              0x00,0x00,0x90,0x00,                        /* Max video frame size in bytes*/
  92                  
  93              0x00,0x02,0x00,0x00              /* No. of bytes device can rx in single payload (512) */
  94          };
  95          
  96          //-----------------------------------------------------------------------------
  97          // Prototypes
  98          //-----------------------------------------------------------------------------
  99          void SetupCommand(void);
 100          void TD_Init(void);
 101          void TD_Poll(void);
 102          BOOL TD_Suspend(void);
 103          BOOL TD_Resume(void);
 104          
 105          BOOL DR_GetDescriptor(void);
 106          BOOL DR_SetConfiguration(void);
 107          BOOL DR_GetConfiguration(void);
 108          BOOL DR_SetInterface(void);
 109          BOOL DR_GetInterface(void);
 110          BOOL DR_GetStatus(void);
 111          BOOL DR_ClearFeature(void);
 112          BOOL DR_SetFeature(void);
 113          BOOL DR_VendorCmnd(void);
 114          
 115          //-----------------------------------------------------------------------------
 116          // Code
C51 COMPILER V7.07   FW                                                                    06/18/2013 00:09:31 PAGE 3   

 117          //-----------------------------------------------------------------------------
 118          
 119          // Task dispatcher
 120          void main(void)
 121          {
 122   1         DWORD   i;
 123   1         WORD   offset;
 124   1         DWORD   DevDescrLen;
 125   1         DWORD   j=0;
 126   1         WORD   IntDescrAddr;
 127   1         WORD   ExtDescrAddr;
 128   1      
 129   1         // Initialize Global States
 130   1         Sleep = FALSE;               // Disable sleep mode
 131   1         Rwuen = FALSE;               // Disable remote wakeup
 132   1         Selfpwr = FALSE;            // Disable self powered
 133   1         GotSUD = FALSE;               // Clear "Got setup data" flag
 134   1      
 135   1         // Initialize user device
 136   1         TD_Init();
 137   1      
 138   1         // The following section of code is used to relocate the descriptor table. 
 139   1         // Since the SUDPTRH and SUDPTRL are assigned the address of the descriptor 
 140   1         // table, the descriptor table must be located in on-part memory.
 141   1         // The 4K demo tools locate all code sections in external memory.
 142   1         // The descriptor table is relocated by the frameworks ONLY if it is found 
 143   1         // to be located in external memory.
 144   1         pDeviceDscr = (WORD)&DeviceDscr;
 145   1         pDeviceQualDscr = (WORD)&DeviceQualDscr;
 146   1         pHighSpeedConfigDscr = (WORD)&HighSpeedConfigDscr;
 147   1         pFullSpeedConfigDscr = (WORD)&FullSpeedConfigDscr;
 148   1         pStringDscr = (WORD)&StringDscr;
 149   1      
 150   1         if (EZUSB_HIGHSPEED())
 151   1         {
 152   2            pConfigDscr = pHighSpeedConfigDscr;
 153   2            pOtherConfigDscr = pFullSpeedConfigDscr;
 154   2         }
 155   1         else
 156   1         {
 157   2            pConfigDscr = pFullSpeedConfigDscr;
 158   2            pOtherConfigDscr = pHighSpeedConfigDscr;
 159   2         }
 160   1      
 161   1         if ((WORD)&DeviceDscr & 0xe000)
 162   1         {
 163   2            IntDescrAddr = INTERNAL_DSCR_ADDR;
 164   2            ExtDescrAddr = (WORD)&DeviceDscr;
 165   2            DevDescrLen = (WORD)&UserDscr - (WORD)&DeviceDscr + 2;
 166   2            for (i = 0; i < DevDescrLen; i++)
 167   2               *((BYTE xdata *)IntDescrAddr+i) = 0xCD;
 168   2            for (i = 0; i < DevDescrLen; i++)
 169   2               *((BYTE xdata *)IntDescrAddr+i) = *((BYTE xdata *)ExtDescrAddr+i);
 170   2            pDeviceDscr = IntDescrAddr;
 171   2            offset = (WORD)&DeviceDscr - INTERNAL_DSCR_ADDR;
 172   2            pDeviceQualDscr -= offset;
 173   2            pConfigDscr -= offset;
 174   2            pOtherConfigDscr -= offset;
 175   2            pHighSpeedConfigDscr -= offset;
 176   2            pFullSpeedConfigDscr -= offset;
 177   2            pStringDscr -= offset;
 178   2         }
C51 COMPILER V7.07   FW                                                                    06/18/2013 00:09:31 PAGE 4   

 179   1      
 180   1         EZUSB_IRQ_ENABLE();            // Enable USB interrupt (INT2)
 181   1         EZUSB_ENABLE_RSMIRQ();            // Wake-up interrupt
 182   1      
 183   1         INTSETUP |= (bmAV2EN | bmAV4EN);     // Enable INT 2 & 4 autovectoring
 184   1      
 185   1         USBIE |= bmSUDAV | bmSUTOK | bmSUSP | bmURES | bmHSGRANT;   // Enable selected interrupts
 186   1         EA = 1;                  // Enable 8051 interrupts
 187   1      
 188   1         #ifndef NO_RENUM
 189   1         // Note: at full speed, high speed hosts may take 5 sec to detect device
 190   1         EZUSB_Discon(TRUE); // Renumerate
 191   1         #endif
 192   1      
 193   1         CKCON = (CKCON&(~bmSTRETCH)) | FW_STRETCH_VALUE; // Set stretch to 0 (after renumeration)
 194   1      
 195   1         // clear the Sleep flag.
 196   1         Sleep = FALSE;
 197   1      
 198   1         // Task Dispatcher
 199   1         while(TRUE)               // Main Loop
 200   1         {
 201   2            if(GotSUD)            // Wait for SUDAV
 202   2            {
 203   3               SetupCommand();          // Implement setup command
 204   3                 GotSUD = FALSE;            // Clear SUDAV flag
 205   3            }
 206   2                else
 207   2                {
 208   3                      TD_Poll();        
 209   3                }
 210   2      
 211   2            // Poll User Device
 212   2            // NOTE: Idle mode stops the processor clock.  There are only two
 213   2            // ways out of idle mode, the WAKEUP pin, and detection of the USB
 214   2            // resume state on the USB bus.  The timers will stop and the
 215   2            // processor will not wake up on any other interrupts.
 216   2            if (Sleep)
 217   2                {
 218   3                if(TD_Suspend())
 219   3                    { 
 220   4                    Sleep = FALSE;            // Clear the "go to sleep" flag.  Do it here to prevent any race c
             -ondition between wakeup and the next sleep.
 221   4                    do
 222   4                        {
 223   5                          EZUSB_Susp();         // Place processor in idle mode.
 224   5                        }
 225   4                      while(!Rwuen && EZUSB_EXTWAKEUP());
 226   4                      // Must continue to go back into suspend if the host has disabled remote wakeup
 227   4                      // *and* the wakeup was caused by the external wakeup pin.
 228   4                      
 229   4                   // 8051 activity will resume here due to USB bus or Wakeup# pin activity.
 230   4                   EZUSB_Resume();   // If source is the Wakeup# pin, signal the host to Resume.      
 231   4                   TD_Resume();
 232   4                    }   
 233   3                }
 234   2            
 235   2         }
 236   1      }
 237          
 238          // Device request parser
 239          void SetupCommand(void)
C51 COMPILER V7.07   FW                                                                    06/18/2013 00:09:31 PAGE 5   

 240          {
 241   1         void   *dscr_ptr;
 242   1        
 243   1                 switch(SETUPDAT[1])
 244   1                 {
 245   2      
 246   2                              case GET_CUR:
 247   2                              case GET_MIN:
 248   2                              case GET_MAX:
 249   2                                      for (i=0;i<=25;i++)
 250   2                                      EP0BUF[i] = valuesArray[i];
 251   2                                      EP0BCH = 0;
 252   2                                      EP0BCL = 26;//SETUPDAT[7];                              
 253   2                              break;
 254   2                                                      
 255   2                              
 256   2                              case SET_LINE_CODING:
 257   2      
 258   2                                      Len = 7;
 259   2                                      EUSB = 0 ;
 260   2                                      SUDPTRCTL = 0x01;
 261   2                                      EP0BCL = 0x00;
 262   2                                      SUDPTRCTL = 0x00;
 263   2                                      EUSB = 1;
 264   2                                      
 265   2                                      while (EP0BCL != Len);
 266   2                                      SYNCDELAY;
 267   2                                      for (i=0;i<Len;i++)
 268   2                                      LineCode[i] = EP0BUF[i];
 269   2                                      // Serial0Init();
 270   2                              break;
 271   2      
 272   2      
 273   2                              case GET_LINE_CODING:
 274   2                                      
 275   2                                      SUDPTRCTL = 0x01;
 276   2                                      Len = 7;
 277   2                                      for (i=0;i<Len;i++)
 278   2                                      EP0BUF[i] = LineCode[i];
 279   2      
 280   2                                      EP0BCH = 0x00;
 281   2                                      SYNCDELAY;
 282   2                                      EP0BCL = Len;
 283   2                                      SYNCDELAY;
 284   2                                      while (EP0CS & 0x02);
 285   2                                      SUDPTRCTL = 0x00;
 286   2                              break;
 287   2      
 288   2                         case SET_CONTROL_STATE:
 289   2                         break;
 290   2      
 291   2      
 292   2                        case SC_GET_DESCRIPTOR: 
 293   2                                               // *** Get Descriptor
 294   2                        SUDPTRCTL = 0x01;
 295   2                               if(DR_GetDescriptor())
 296   2                                      switch(SETUPDAT[3])         
 297   2                                      {
 298   3                                         case GD_DEVICE:            // Device
 299   3                                                SUDPTRH = MSB(pDeviceDscr);
 300   3                                                SUDPTRL = LSB(pDeviceDscr);
 301   3                                                break;
C51 COMPILER V7.07   FW                                                                    06/18/2013 00:09:31 PAGE 6   

 302   3                                         case GD_DEVICE_QUALIFIER:            // Device Qualifier
 303   3                                                SUDPTRH = MSB(pDeviceQualDscr);
 304   3                                                SUDPTRL = LSB(pDeviceQualDscr);
 305   3                                                break;
 306   3                                         case GD_CONFIGURATION:         // Configuration
 307   3                                                SUDPTRH = MSB(pConfigDscr);
 308   3                                                SUDPTRL = LSB(pConfigDscr);
 309   3                                                break;
 310   3                                         case GD_OTHER_SPEED_CONFIGURATION:  // Other Speed Configuration
 311   3                                                // fx2bug - need to support multi other configs
 312   3                                                SUDPTRH = MSB(pOtherConfigDscr);
 313   3                                                SUDPTRL = LSB(pOtherConfigDscr);
 314   3                                                break;
 315   3                                         case GD_STRING:            // String
 316   3                                                if(dscr_ptr = (void *)EZUSB_GetStringDscr(SETUPDAT[2]))
 317   3                                                {
 318   4                                                       SUDPTRH = MSB(dscr_ptr);
 319   4                                                       SUDPTRL = LSB(dscr_ptr);
 320   4                                                }
 321   3                                                else 
 322   3                                                       EZUSB_STALL_EP0();   // Stall End Point 0
 323   3                                                break;
 324   3                                         default:            // Invalid request
 325   3                                                EZUSB_STALL_EP0();      // Stall End Point 0
 326   3                                      }
 327   2                               break;
 328   2                        case SC_GET_INTERFACE:                  // *** Get Interface
 329   2                               DR_GetInterface();
 330   2                               break;
 331   2                        case SC_SET_INTERFACE:                  // *** Set Interface
 332   2                               DR_SetInterface();
 333   2                               break;
 334   2                        case SC_SET_CONFIGURATION:               // *** Set Configuration
 335   2                               DR_SetConfiguration();
 336   2                               break;
 337   2                        case SC_GET_CONFIGURATION:               // *** Get Configuration
 338   2                               DR_GetConfiguration();
 339   2                               break;
 340   2                        case SC_GET_STATUS:                  // *** Get Status
 341   2                               if(DR_GetStatus())
 342   2                                      switch(SETUPDAT[0])
 343   2                                      {
 344   3                                         case GS_DEVICE:            // Device
 345   3                                                EP0BUF[0] = ((BYTE)Rwuen << 1) | (BYTE)Selfpwr;
 346   3                                                EP0BUF[1] = 0;
 347   3                                                EP0BCH = 0;
 348   3                                                EP0BCL = 2;
 349   3                                                break;
 350   3                                         case GS_INTERFACE:         // Interface
 351   3                                                EP0BUF[0] = 0;
 352   3                                                EP0BUF[1] = 0;
 353   3                                                EP0BCH = 0;
 354   3                                                EP0BCL = 2;
 355   3                                                break;
 356   3                                         case GS_ENDPOINT:         // End Point
 357   3              // fx2bug                  EP0BUF[0] = EPIO[EPID(SETUPDAT[4])].cntrl & bmEPSTALL;
 358   3      
 359   3                                                EP0BUF[1] = 0;
 360   3                                                EP0BCH = 0;
 361   3                                                EP0BCL = 2;
 362   3                                                break;
 363   3                                         default:            // Invalid Command
C51 COMPILER V7.07   FW                                                                    06/18/2013 00:09:31 PAGE 7   

 364   3                                                EZUSB_STALL_EP0();      // Stall End Point 0
 365   3                                      }
 366   2                               break;
 367   2                        case SC_CLEAR_FEATURE:                  // *** Clear Feature
 368   2                              if ((SETUPDAT[0]==UVC_SET_INTERFACE)|(SETUPDAT[0]==UVC_GET_INTERFACE)|(SETUPDAT[0]==UVC_SET_ENDPOINT)|(
             -SETUPDAT[0]==UVC_GET_ENDPOINT)) {
 369   3                                      EP0BCH = 0; // ACK
 370   3                                      EP0BCL = 0; // ACK
 371   3                              }
 372   2                              
 373   2                              else 
 374   2                              if(DR_ClearFeature())
 375   2                                      switch(SETUPDAT[0])
 376   2                                      {
 377   3                                         case FT_DEVICE:            // Device
 378   3                                                if(SETUPDAT[2] == 1)
 379   3                                                       Rwuen = FALSE;       // Disable Remote Wakeup
 380   3                                                else
 381   3                                                       EZUSB_STALL_EP0();   // Stall End Point 0
 382   3                                                break;
 383   3                                         case FT_ENDPOINT:         // End Point
 384   3                                                if(SETUPDAT[2] == 0)
 385   3                                                {
 386   4              // fx2bug                     EZUSB_UNSTALL_EP( EPID(SETUPDAT[4]) );
 387   4              // fx2bug                     EZUSB_RESET_DATA_TOGGLE( SETUPDAT[4] );
 388   4                                                }
 389   3                                                else
 390   3                                                       EZUSB_STALL_EP0();   // Stall End Point 0
 391   3                                                break;
 392   3                                      }
 393   2                               break;
 394   2                        case SC_SET_FEATURE:                  // *** Set Feature
 395   2                               if(DR_SetFeature())
 396   2                                      switch(SETUPDAT[0])
 397   2                                      {
 398   3                                         case FT_DEVICE:            // Device
 399   3                                                if(SETUPDAT[2] == 1)
 400   3                                                       Rwuen = TRUE;      // Enable Remote Wakeup
 401   3                                                else
 402   3                                                       EZUSB_STALL_EP0();   // Stall End Point 0
 403   3                                                break;
 404   3                                         case FT_ENDPOINT:         // End Point
 405   3              // fx2bug                  if(SETUPDAT[2] == 0)
 406   3              // fx2bug                     EZUSB_STALL_EP( EPID(SETUPDAT[4]) );
 407   3              // fx2bug                  else
 408   3                                                       EZUSB_STALL_EP0();    // Stall End Point 0
 409   3                                                break;
 410   3                                      }
 411   2                               break;
 412   2                        default:                     // *** Invalid Command
 413   2                               if(DR_VendorCmnd())
 414   2                                      EZUSB_STALL_EP0();            // Stall End Point 0
 415   2                 }
 416   1         
 417   1      
 418   1      
 419   1      
 420   1         // Acknowledge handshake phase of device request
 421   1         // Required for rev C does not effect rev B
 422   1      // TGE fx2bug   EP0CS |= bmBIT1; 
 423   1          EP0CS |= bmHSNAK;
 424   1      }
C51 COMPILER V7.07   FW                                                                    06/18/2013 00:09:31 PAGE 8   

 425          
 426          // Wake-up interrupt handler
 427          void resume_isr(void) interrupt WKUP_VECT
 428          {
 429   1         EZUSB_CLEAR_RSMIRQ();
 430   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1116    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     43      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
