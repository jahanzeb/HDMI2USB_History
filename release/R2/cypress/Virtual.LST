C51 COMPILER V7.07   VIRTUAL                                                               06/18/2013 00:09:31 PAGE 1   


C51 COMPILER V7.07, COMPILATION OF MODULE VIRTUAL
OBJECT MODULE PLACED IN Virtual.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Virtual.c BROWSE INCDIR(C:\Documents and Settings\prku\Desktop\UART Debug\)
                    - DEBUG OBJECTEXTEND

stmt level    source

   1          #pragma NOIV               // Do not generate interrupt vectors
   2          //-----------------------------------------------------------------------------
   3          //   File:      bulkloop.c
   4          //   Contents:   Hooks required to implement USB peripheral function.
   5          //
   6          //   Copyright (c) 2000 Cypress Semiconductor All rights reserved
   7          //-----------------------------------------------------------------------------
   8          #include "fx2.h"
   9          #include "fx2regs.h"
  10          #include "fx2sdly.h"                    // SYNCDELAY macro
  11          extern BOOL   GotSUD;         // Received setup data flag
  12          extern BOOL   Sleep;
  13          extern BOOL   Rwuen;
  14          extern BOOL   Selfpwr;
  15          xdata volatile unsigned char D3ON         _at_ 0x9800;
  16          xdata volatile unsigned char D3OFF        _at_ 0x9000;
  17           static int x;
  18           unsigned char duk; 
  19           static int bcl,i;
  20          
  21          xdata volatile unsigned char D5ON         _at_ 0xB800;
  22          xdata volatile unsigned char D5OFF        _at_ 0xB000;
  23          
  24           unsigned char dum;
  25           static int z;
  26          
  27          extern BYTE xdata LineCode[7] ;
  28          
  29          BYTE   Configuration;      // Current configuration
  30          BYTE   AlternateSetting;   // Alternate settings
  31          
  32          void display_product(void);
  33          void TD_Poll(void);
  34          
  35          
  36          //-----------------------------------------------------------------------------
  37          // Task Dispatcher hooks
  38          //   The following hooks are called by the task dispatcher.
  39          //-----------------------------------------------------------------------------
  40          BOOL DR_SetConfiguration();
  41          
  42             
  43             // BYTE TxByte0,RxByte0;
  44             // BYTE TxByte1,RxByte1;
  45          
  46          // void transmit(void)// Sends data to SBUF0 
  47          // {
  48                  // if (!(EP1OUTCS & 0x02)) 
  49                  // {
  50                   
  51                          // if(i<bcl)
  52                          // {
  53                           
  54                                  // SBUF0=EP1OUTBUF[i];
C51 COMPILER V7.07   VIRTUAL                                                               06/18/2013 00:09:31 PAGE 2   

  55                                  // i++;
  56                                   
  57                                  // dum=D5ON;
  58                                  // z^=1;
  59                                  // if (z)
  60                                  // {dum=D5OFF;}  
  61                          // }
  62                          // else
  63                          // {
  64                                  // EP1OUTBC = 0x04;// Arms EP1 endpoint
  65                          // }
  66                  // }
  67          // }
  68          
  69          
  70          // void  Serial0Init () // serial UART 0 with Timer 2 in mode 1 or high speed baud rate generator
  71          // {
  72                          
  73                      // UART230 &= 0x03;
  74          
  75                          // if ((LineCode[0] == 0x60) && (LineCode[1] == 0x09 ))   // 2400
  76          
  77                          // {
  78                          // SCON0  = 0x5A;                   //  Set Serial Mode = 1, Recieve enable bit = 1
  79                                  // T2CON  = 0x34;                   //  Int1 is detected on falling edge, Enable Timer0, Set Timer overflow Flag
  80                                  // RCAP2H = 0xFD;               //  Set TH2 value for timer2 
  81                                  // RCAP2L = 0x90;               //      baud rate is set to 2400 baud
  82                                  // TH2    = RCAP2H;             //  Upper 8 bit of 16 bit counter to FF
  83                                  // TL2    = RCAP2L;             //  value of the lower 8 bits of timer set to baud rate
  84          
  85                          // }
  86             // else if ((LineCode[0] == 0xC0) && (LineCode[1] == 0x12 ))   // 4800
  87          
  88                          // {
  89                          // SCON0  = 0x5A;                   //  Set Serial Mode = 1, Recieve enable bit = 1
  90                                  // T2CON  = 0x34;                   //  Int1 is detected on falling edge, Enable Timer0, Set Timer overflow Flag
  91                                  // RCAP2H = 0xFE;               //  Set TH2 value for timer2 
  92                                  // RCAP2L = 0xC8;               //      baud rate is set to 4800 baud
  93                                  // TH2    = RCAP2H;             //  Upper 8 bit of 16 bit counter to FF
  94                                  // TL2    = RCAP2L;             //  value of the lower 8 bits of timer set to baud rate
  95          
  96                          // }
  97                          // else if ((LineCode[0] == 0x80) && (LineCode[1] == 0x25 ))      // 9600
  98          
  99                          // {
 100                          // SCON0  = 0x5A;                   //  Set Serial Mode = 1, Recieve enable bit = 1
 101                                  // T2CON  = 0x34;                   //  Int1 is detected on falling edge, Enable Timer0, Set Timer overflow Flag
 102                                  // RCAP2H = 0xFF;               //  Set TH2 value for timer2 
 103                                  // RCAP2L = 0x64;               //      baud rate is set to 9600 baud
 104                                  // TH2    = RCAP2H;             //  Upper 8 bit of 16 bit counter to FF
 105                                  // TL2    = RCAP2L;             //  value of the lower 8 bits of timer set to baud rate
 106          
 107                          // }
 108                          // else if ((LineCode[0] == 0x00) && (LineCode[1] == 0x4B ))      // 19200
 109          
 110                          // {
 111                          // SCON0  = 0x5A;                   //  Set Serial Mode = 1, Recieve enable bit = 1
 112                                  // T2CON  = 0x34;                   //  Int1 is detected on falling edge, Enable Timer0, Set Timer overflow Flag
 113                                  // RCAP2H = 0xFF;               //  Set TH2 value for timer2 
 114                                  // RCAP2L = 0xB2;               //      baud rate is set to 19200 baud
 115                                  // TH2    = RCAP2H;             //  Upper 8 bit of 16 bit counter to FF
 116                                  // TL2    = RCAP2L;             //  value of the lower 8 bits of timer set to baud rate
C51 COMPILER V7.07   VIRTUAL                                                               06/18/2013 00:09:31 PAGE 3   

 117          
 118                          // }
 119                          // else if ((LineCode[0] == 0x80) && (LineCode[1] == 0x70 ))      // 28800
 120          
 121                          // {
 122                          // SCON0  = 0x5A;                   //  Set Serial Mode = 1, Recieve enable bit = 1
 123                                  // T2CON  = 0x34;                   //  Int1 is detected on falling edge, Enable Timer0, Set Timer overflow Flag
 124                                  // RCAP2H = 0xFF;               //  Set TH2 value for timer2 
 125                                  // RCAP2L = 0xCC;               //      baud rate is set to 28800 baud
 126                                  // TH2    = RCAP2H;             //  Upper 8 bit of 16 bit counter to FF
 127                                  // TL2    = RCAP2L;             //  value of the lower 8 bits of timer set to baud rate
 128          
 129                          // }
 130                          // else if ((LineCode[0] == 0x00) && (LineCode[1] == 0x96 ))      // 38400
 131          
 132                          // {
 133                          // SCON0  = 0x5A;                   //  Set Serial Mode = 1, Recieve enable bit = 1
 134                                  // T2CON  = 0x34;                   //  Int1 is detected on falling edge, Enable Timer0, Set Timer overflow Flag
 135                                  // RCAP2H = 0xFF;               //  Set TH2 value for timer2 
 136                                  // RCAP2L = 0xD9;               //      baud rate is set to 38400 baud
 137                                  // TH2    = RCAP2H;             //  Upper 8 bit of 16 bit counter to FF
 138                                  // TL2    = RCAP2L;             //  value of the lower 8 bits of timer set to baud rate
 139          
 140                          // }
 141                          // else if ((LineCode[0] == 0x00) && (LineCode[1] == 0xE1 ))      // 57600
 142          
 143                          // {
 144                          // SCON0  = 0x5A;                   //  Set Serial Mode = 1, Recieve enable bit = 1
 145                                  // T2CON  = 0x34;                   //  Int1 is detected on falling edge, Enable Timer0, Set Timer overflow Flag
 146                                  // RCAP2H = 0xFF;               //  Set TH2 value for timer2 
 147                                  // RCAP2L = 0xE6;               //      baud rate is set to 57600 baud
 148                                  // TH2    = RCAP2H;             //  Upper 8 bit of 16 bit counter to FF
 149                                  // TL2    = RCAP2L;             //  value of the lower 8 bits of timer set to baud rate
 150          
 151                          // }
 152                  
 153                 // else if ((LineCode[0] == 0x00) && (LineCode[1] == 0x84 ))       // 230400 
 154                          // {
 155                               // PCON |= 0X80;
 156                      // UART230 |= 0x03;
 157                              
 158                          // }
 159                                  // else //if ((LineCode[0] == 0x21) && (LineCode[1] == 0x20 ))    // 115200 (LineCode[0] == 0x00) && (Li
             -neCode[1] == 0xC2 ))
 160          
 161                          // {
 162                             
 163                             // SCON0  = 0x5A;                //  Set Serial Mode = 1, Recieve enable bit = 1
 164                                  // T2CON  = 0x34;       
 165                             // RCAP2L = 0xF3; 
 166                     // RCAP2H = 0xFF; 
 167                             // TH2    = RCAP2H;          //  Upper 8 bit of 16 bit counter to FF
 168                                  // TL2    = RCAP2L;             //  value of the lower 8 bits of timer set to baud rate*/
 169          
 170          
 171                              
 172                          // }
 173                 
 174          
 175          // }
 176          
 177          
C51 COMPILER V7.07   VIRTUAL                                                               06/18/2013 00:09:31 PAGE 4   

 178          
 179          
 180          void TD_Init(void)             // Called once at startup
 181          {
 182   1         
 183   1         
 184   1      // set the CPU clock to 48MHz
 185   1           CPUCS = ((CPUCS & ~bmCLKSPD) | bmCLKSPD1) ;
 186   1      
 187   1      REVCTL = 0x03;   
 188   1      SYNCDELAY; 
 189   1      
 190   1      EP2CFG = 0xA2;                //out 512 bytes, 2x, bulk
 191   1      SYNCDELAY; 
 192   1      
 193   1      EP6CFG = 0xD2;                // in 512 bytes, 2x, iso 1101  
 194   1      SYNCDELAY;  
 195   1             
 196   1      EP4CFG = 0xE2;                // in 512 bytes, 2x, bulk
 197   1      SYNCDELAY;                     
 198   1      
 199   1      EP8CFG = 0x02;                //clear valid bit
 200   1      SYNCDELAY;   
 201   1      
 202   1      IFCONFIG = 0xE3; //1110 0011 
 203   1      SYNCDELAY;
 204   1      
 205   1      FIFOPINPOLAR = 0x00;
 206   1      SYNCDELAY;
 207   1      
 208   1      PINFLAGSAB = 0x00;                      // 
 209   1      SYNCDELAY;
 210   1      PINFLAGSCD = 0x00;                      // 
 211   1      SYNCDELAY;
 212   1      
 213   1      PORTACFG |= 0x80; // port A configuration reg
 214   1      SYNCDELAY;
 215   1      
 216   1      SYNCDELAY;
 217   1      FIFORESET = 0x80;             // activate NAK-ALL to avoid race conditions
 218   1      SYNCDELAY;                    // see TRM section 15.14
 219   1      FIFORESET = 0x02;             // reset, FIFO 2
 220   1      SYNCDELAY;                    // 
 221   1      FIFORESET = 0x04;             // reset, FIFO 4
 222   1      SYNCDELAY;                    // 
 223   1      FIFORESET = 0x06;             // reset, FIFO 6
 224   1      SYNCDELAY;                    // 
 225   1      FIFORESET = 0x08;             // reset, FIFO 8
 226   1      SYNCDELAY;                    // 
 227   1      FIFORESET = 0x00;             // deactivate NAK-ALL
 228   1      
 229   1      SYNCDELAY;                    // 
 230   1      
 231   1      
 232   1      SYNCDELAY;                    // 
 233   1      EP4FIFOCFG = 0x0C;            // AUTOIN=1, ZEROLENIN=1, WORDWIDE=0
 234   1      
 235   1      SYNCDELAY;  
 236   1      EP6FIFOCFG = 0x0C;            // AUTOIN=1, ZEROLENIN=1, WORDWIDE=0
 237   1      
 238   1      SYNCDELAY;
 239   1      EP8FIFOCFG = 0x00; // disabled
C51 COMPILER V7.07   VIRTUAL                                                               06/18/2013 00:09:31 PAGE 5   

 240   1      
 241   1      
 242   1      
 243   1      SYNCDELAY;
 244   1      EP4AUTOINLENH = 0x02; // EZ-USB automatically commits data in 512-byte chunks
 245   1      
 246   1      SYNCDELAY;
 247   1      EP4AUTOINLENL = 0x00;
 248   1      
 249   1      SYNCDELAY;
 250   1      EP6AUTOINLENH = 0x02; // EZ-USB automatically commits data in 512-byte chunks
 251   1      
 252   1      SYNCDELAY;
 253   1      EP6AUTOINLENL = 0x00;
 254   1      SYNCDELAY; 
 255   1      
 256   1      
 257   1      
 258   1      
 259   1      EP2AUTOINLENH = 0x02; // EZ-USB automatically commits data in 512-byte chunks
 260   1      SYNCDELAY;
 261   1      EP2AUTOINLENL = 0x00;
 262   1      EP2FIFOCFG = 0x10;            // AUTOOUT=1, WORDWIDE=0
 263   1      
 264   1      // EP2FIFOCFG = 0x00; // EP2 is AUTOOUT=0, AUTOIN=0, ZEROLEN=0, WORDWIDE=0
 265   1      // SYNCDELAY;
 266   1      // OUTPKTEND = 0x82; // Arm both EP2 buffers to “prime the pump”
 267   1      // SYNCDELAY;
 268   1      // OUTPKTEND = 0x82;
 269   1      
 270   1      
 271   1      
 272   1      }
 273          
 274          void TD_Poll(void)             // Called repeatedly while the device is idle
 275          {
 276   1        // return;
 277   1        // Serial State Notification that has to be sent periodically to the host
 278   1      
 279   1        
 280   1      // if( !( EP2468STAT & 0x01 ) )
 281   1      // { // EP2EF=0 when FIFO NOT empty, host sent packet
 282   1      // OUTPKTEND = 0x82; // SKIP=0, pass buffer on to master
 283   1      // }
 284   1      
 285   1      
 286   1      if (!(EP1INCS & 0x02))      // check if EP1IN is available
 287   1                {
 288   2                      EP1INBUF[0] = 0x0A;       // if it is available, then fill the first 10 bytes of the buffer with 
 289   2                      EP1INBUF[1] = 0x20;       // appropriate data. 
 290   2                      EP1INBUF[2] = 0x00;
 291   2                      EP1INBUF[3] = 0x00;
 292   2                      EP1INBUF[4] = 0x00;
 293   2                      EP1INBUF[5] = 0x00;
 294   2                      EP1INBUF[6] = 0x00;
 295   2                      EP1INBUF[7] = 0x02;
 296   2                      EP1INBUF[8] = 0x00;
 297   2                      EP1INBUF[9] = 0x00;
 298   2                      EP1INBC = 10;            // manually commit once the buffer is filled
 299   2                }
 300   1       
 301   1      
C51 COMPILER V7.07   VIRTUAL                                                               06/18/2013 00:09:31 PAGE 6   

 302   1      }
 303          
 304          BOOL TD_Suspend(void)          // Called before the device goes into suspend mode
 305          {
 306   1         return(TRUE);
 307   1      }
 308          
 309          BOOL TD_Resume(void)          // Called after the device resumes
 310          {
 311   1         return(TRUE);
 312   1      }
 313          
 314          //-----------------------------------------------------------------------------
 315          // Device Request hooks
 316          //   The following hooks are called by the end point 0 device request parser.
 317          //-----------------------------------------------------------------------------
 318          
 319          BOOL DR_GetDescriptor(void)
 320          {
 321   1         return(TRUE);
 322   1      }
 323          
 324          BOOL DR_SetConfiguration(void)   // Called when a Set Configuration command is received
 325          {  
 326   1      
 327   1         Configuration = SETUPDAT[2];
 328   1         return(TRUE);            // Handled by user code
 329   1      }
 330          
 331          BOOL DR_GetConfiguration(void)   // Called when a Get Configuration command is received
 332          {
 333   1         EP0BUF[0] = Configuration;
 334   1         EP0BCH = 0;
 335   1         EP0BCL = 1;
 336   1         return(TRUE);            // Handled by user code
 337   1      }
 338          
 339          BOOL DR_SetInterface(void)       // Called when a Set Interface command is received
 340          {
 341   1         
 342   1         AlternateSetting = SETUPDAT[2];
 343   1         
 344   1      
 345   1         
 346   1         if (AlternateSetting == 1 )
 347   1         {
 348   2                      
 349   2      
 350   2                      // SYNCDELAY; //
 351   2                      // FIFORESET = 0x80; // nak all OUT pkts. from host
 352   2                      // SYNCDELAY; //
 353   2                      
 354   2                      // EP2FIFOCFG = 0x00; //switching to manual mode
 355   2                      // SYNCDELAY;
 356   2      
 357   2                      // FIFORESET = 0x02; // advance all EP2 buffers to cpu domain
 358   2                      
 359   2                      
 360   2                      // SYNCDELAY;
 361   2                      // OUTPKTEND = 0X82; //OUTPKTEND done twice as EP2 is double buffered by default
 362   2                      // SYNCDELAY;
 363   2                      // OUTPKTEND = 0X82;
C51 COMPILER V7.07   VIRTUAL                                                               06/18/2013 00:09:31 PAGE 7   

 364   2                      
 365   2                      // SYNCDELAY; //
 366   2                      // EP2FIFOBUF[0] = 0x55; // create newly sourced pkt. data //55:4a:55:48:55:4e
 367   2                      // SYNCDELAY; //
 368   2                      // EP2FIFOBUF[1] = 0x4a; // create newly sourced pkt. data //55:4a:55:48:55:4e
 369   2                      // SYNCDELAY; //                
 370   2                      // EP2FIFOBUF[2] = 0x55; // create newly sourced pkt. data //55:4a:55:48:55:4e
 371   2                      // SYNCDELAY; //                
 372   2                      // EP2FIFOBUF[3] = 0x48; // create newly sourced pkt. data //55:4a:55:48:55:4e
 373   2                      // SYNCDELAY; //                
 374   2                      // EP2FIFOBUF[4] = 0x55; // create newly sourced pkt. data //55:4a:55:48:55:4e
 375   2                      // SYNCDELAY; //                
 376   2                      // EP2FIFOBUF[5] = 0x4e; // create newly sourced pkt. data //55:4a:55:48:55:4e
 377   2                      // SYNCDELAY; //
 378   2      
 379   2                      //S = 53
 380   2                      
 381   2                      // SYNCDELAY; //
 382   2                      // EP2FIFOBUF[0] = 0x53; // create newly sourced pkt. data //55:4a:55:48:55:4e
 383   2                      // SYNCDELAY; //
 384   2                      // EP2FIFOBUF[1] = 0x53; // create newly sourced pkt. data //55:4a:55:48:55:4e
 385   2                      // SYNCDELAY; //                
 386   2                      
 387   2                      
 388   2      
 389   2                      // EP2BCH = 0x00;
 390   2                      // SYNCDELAY; //
 391   2                      // EP2BCL = 0x02; // commit newly sourced pkt. to interface fifo 
 392   2                      // OUTPKTEND = 0X02;
 393   2                      // SYNCDELAY;
 394   2                      // EP2FIFOCFG = 0x10; //switching to auto mode
 395   2                      // SYNCDELAY;
 396   2                      // FIFORESET = 0x00; //Release NAKALL
 397   2                      // SYNCDELAY;
 398   2      
 399   2              }
 400   1         
 401   1         
 402   1         
 403   1         return(TRUE);            // Handled by user code
 404   1      }
 405          
 406          BOOL DR_GetInterface(void)       // Called when a Set Interface command is received
 407          {
 408   1         EP0BUF[0] = AlternateSetting;
 409   1         EP0BCH = 0;
 410   1         EP0BCL = 1;
 411   1         return(TRUE);            // Handled by user code
 412   1      }
 413          
 414          BOOL DR_GetStatus(void)
 415          {
 416   1         return(TRUE);
 417   1      }
 418          
 419          BOOL DR_ClearFeature(void)
 420          {
 421   1         return(TRUE);
 422   1      }
 423          
 424          BOOL DR_SetFeature(void)
 425          {
C51 COMPILER V7.07   VIRTUAL                                                               06/18/2013 00:09:31 PAGE 8   

 426   1         return(TRUE);
 427   1      }
 428          
 429          BOOL DR_VendorCmnd(void)
 430          {
 431   1         return(TRUE);
 432   1      }
 433          
 434          //-----------------------------------------------------------------------------
 435          // USB Interrupt Handlers
 436          //   The following functions are called by the USB interrupt jump table.
 437          //-----------------------------------------------------------------------------
 438          
 439          // Setup Data Available Interrupt Handler
 440          
 441          
 442          void ISR_Sudav(void) interrupt 0
 443          {
 444   1         
 445   1         GotSUD = TRUE;            // Set flag
 446   1         EZUSB_IRQ_CLEAR();
 447   1         USBIRQ = bmSUDAV;         // Clear SUDAV IRQ
 448   1      }
 449          
 450          // Setup Token Interrupt Handler
 451          void ISR_Sutok(void) interrupt 0
 452          {
 453   1         EZUSB_IRQ_CLEAR();
 454   1         USBIRQ = bmSUTOK;         // Clear SUTOK IRQ
 455   1      }
 456          
 457          void ISR_Sof(void) interrupt 0
 458          {
 459   1         EZUSB_IRQ_CLEAR();
 460   1         USBIRQ = bmSOF;            // Clear SOF IRQ
 461   1      }
 462          
 463          void ISR_Ures(void) interrupt 0
 464          {
 465   1         if (EZUSB_HIGHSPEED())
 466   1         {
 467   2            pConfigDscr = pHighSpeedConfigDscr;
 468   2            pOtherConfigDscr = pFullSpeedConfigDscr;
 469   2         }
 470   1         else
 471   1         {
 472   2            pConfigDscr = pFullSpeedConfigDscr;
 473   2            pOtherConfigDscr = pHighSpeedConfigDscr;
 474   2         }
 475   1         
 476   1         EZUSB_IRQ_CLEAR();
 477   1         USBIRQ = bmURES;         // Clear URES IRQ
 478   1      }
 479          
 480          void ISR_Susp(void) interrupt 0
 481          {
 482   1          Sleep = TRUE;
 483   1         EZUSB_IRQ_CLEAR();
 484   1         USBIRQ = bmSUSP;
 485   1        
 486   1      }
 487          
C51 COMPILER V7.07   VIRTUAL                                                               06/18/2013 00:09:31 PAGE 9   

 488          void ISR_Highspeed(void) interrupt 0
 489          {
 490   1         if (EZUSB_HIGHSPEED())
 491   1         {
 492   2            pConfigDscr = pHighSpeedConfigDscr;
 493   2            pOtherConfigDscr = pFullSpeedConfigDscr;
 494   2         }
 495   1         else
 496   1         {
 497   2            pConfigDscr = pFullSpeedConfigDscr;
 498   2            pOtherConfigDscr = pHighSpeedConfigDscr;
 499   2         }
 500   1      
 501   1         EZUSB_IRQ_CLEAR();
 502   1         USBIRQ = bmHSGRANT;
 503   1      }
 504          void ISR_Ep0ack(void) interrupt 0
 505          {
 506   1      }
 507          void ISR_Stub(void) interrupt 0
 508          {
 509   1      }
 510          void ISR_Ep0in(void) interrupt 0
 511          {
 512   1      }
 513          void ISR_Ep0out(void) interrupt 0
 514          {
 515   1      
 516   1      
 517   1      }
 518          void ISR_Ep1in(void) interrupt 0
 519          {
 520   1      }
 521          void ISR_Ep1out(void) interrupt 0// Places first byte of EP1 OUT buffer in SBUF0
 522          {
 523   1              EZUSB_IRQ_CLEAR();              //Clears the USB interrupt
 524   1              EPIRQ = bmBIT3;                 //Clears EP1 OUT interrupt request 
 525   1          while (TI == 1) ;
 526   1               
 527   1              i=0;
 528   1              bcl=EP1OUTBC;
 529   1              SBUF0=EP1OUTBUF[i];
 530   1              i++;
 531   1      
 532   1      }
 533          void ISR_Ep2inout(void) interrupt 0
 534          {
 535   1      }
 536          void ISR_Ep4inout(void) interrupt 0
 537          {
 538   1      
 539   1      }
 540          void ISR_Ep6inout(void) interrupt 0
 541          {
 542   1      }
 543          void ISR_Ep8inout(void) interrupt 0
 544          {
 545   1      }
 546          void ISR_Ibn(void) interrupt 0
 547          {
 548   1      }
 549          void ISR_Ep0pingnak(void) interrupt 0
C51 COMPILER V7.07   VIRTUAL                                                               06/18/2013 00:09:31 PAGE 10  

 550          {
 551   1      }
 552          void ISR_Ep1pingnak(void) interrupt 0
 553          {
 554   1      }
 555          void ISR_Ep2pingnak(void) interrupt 0
 556          {
 557   1      }
 558          void ISR_Ep4pingnak(void) interrupt 0
 559          {
 560   1      }
 561          void ISR_Ep6pingnak(void) interrupt 0
 562          {
 563   1      }
 564          void ISR_Ep8pingnak(void) interrupt 0
 565          {
 566   1      }
 567          void ISR_Errorlimit(void) interrupt 0
 568          {
 569   1      }
 570          void ISR_Ep2piderror(void) interrupt 0
 571          {
 572   1      }
 573          void ISR_Ep4piderror(void) interrupt 0
 574          {
 575   1      }
 576          void ISR_Ep6piderror(void) interrupt 0
 577          {
 578   1      }
 579          void ISR_Ep8piderror(void) interrupt 0
 580          {
 581   1      }
 582          void ISR_Ep2pflag(void) interrupt 0
 583          {
 584   1      }
 585          void ISR_Ep4pflag(void) interrupt 0
 586          {
 587   1      }
 588          void ISR_Ep6pflag(void) interrupt 0
 589          {
 590   1      }
 591          void ISR_Ep8pflag(void) interrupt 0
 592          {
 593   1      }
 594          void ISR_Ep2eflag(void) interrupt 0
 595          {
 596   1      }
 597          void ISR_Ep4eflag(void) interrupt 0
 598          {
 599   1      }
 600          void ISR_Ep6eflag(void) interrupt 0
 601          {
 602   1      }
 603          void ISR_Ep8eflag(void) interrupt 0
 604          {
 605   1      }
 606          void ISR_Ep2fflag(void) interrupt 0
 607          {
 608   1      }
 609          void ISR_Ep4fflag(void) interrupt 0
 610          {
 611   1      }
C51 COMPILER V7.07   VIRTUAL                                                               06/18/2013 00:09:31 PAGE 11  

 612          void ISR_Ep6fflag(void) interrupt 0
 613          {
 614   1      }
 615          void ISR_Ep8fflag(void) interrupt 0
 616          {
 617   1      }
 618          void ISR_GpifComplete(void) interrupt 0
 619          {
 620   1      }
 621          void ISR_GpifWaveform(void) interrupt 0
 622          {
 623   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    631    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
